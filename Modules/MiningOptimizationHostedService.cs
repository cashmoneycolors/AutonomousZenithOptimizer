using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Diagnostics;
using System.Text.Json;
using ZenithCoreSystem.Core;
using ZenithCoreSystem.Modules;

namespace ZenithCoreSystem.Modules;

/// <summary>
/// Background service that periodically runs Python-based mining optimization
/// and integrates results into the A.Z.O. system cache.
/// </summary>
public class MiningOptimizationHostedService : BackgroundService
{
    private readonly ILogger<MiningOptimizationHostedService> _logger;
    private readonly IDatabase _db;
    private readonly OptimizerSettings _settings;
    private readonly string _pythonExecutable;
    private readonly string _optimizationScript;

    public MiningOptimizationHostedService(
        ILogger<MiningOptimizationHostedService> logger,
        IConnectionMultiplexer cache,
        IOptions<OptimizerSettings> settings)
    {
        _logger = logger;
        _db = cache.GetDatabase(0);
        _settings = settings.Value;
        
        // Determine Python executable path
        _pythonExecutable = _settings.PythonExecutablePath ?? "python";
        
        // Path to optimization dashboard script
        _optimizationScript = Path.Combine(
            AppDomain.CurrentDomain.BaseDirectory,
            "python_modules",
            "mining_optimization_dashboard.py"
        );
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (!_settings.EnableMiningOptimization)
        {
            _logger.LogInformation("Mining Optimization Service ist deaktiviert (siehe appsettings.json)");
            return;
        }

        _logger.LogInformation("Mining Optimization Service gestartet - Intervall: {Interval}s", 
            _settings.MiningOptimizationIntervalSeconds);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await RunOptimizationCycle(stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Fehler beim Mining Optimization Zyklus");
            }

            await Task.Delay(
                TimeSpan.FromSeconds(_settings.MiningOptimizationIntervalSeconds), 
                stoppingToken);
        }

        _logger.LogInformation("Mining Optimization Service wird beendet");
    }

    private async Task RunOptimizationCycle(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Starte Mining Optimization Zyklus...");

        if (!File.Exists(_optimizationScript))
        {
            _logger.LogWarning("Python Optimization Script nicht gefunden: {Path}", _optimizationScript);
            return;
        }

        try
        {
            // Run Python optimization script
            var processInfo = new ProcessStartInfo
            {
                FileName = _pythonExecutable,
                Arguments = $"\"{_optimizationScript}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true,
                WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory
            };

            using var process = Process.Start(processInfo);
            if (process == null)
            {
                _logger.LogError("Python Prozess konnte nicht gestartet werden");
                return;
            }

            var outputTask = process.StandardOutput.ReadToEndAsync(cancellationToken);
            var errorTask = process.StandardError.ReadToEndAsync(cancellationToken);

            await process.WaitForExitAsync(cancellationToken);

            var output = await outputTask;
            var error = await errorTask;

            if (process.ExitCode == 0)
            {
                _logger.LogInformation("Python Optimization erfolgreich abgeschlossen");
                
                // Parse and cache the optimization results
                await CacheOptimizationResults(output, cancellationToken);
            }
            else
            {
                _logger.LogError("Python Optimization fehlgeschlagen (Exit Code: {ExitCode})\nStderr: {Error}", 
                    process.ExitCode, error);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Fehler beim Ausf√ºhren des Python Optimization Scripts");
        }
    }

    private async Task CacheOptimizationResults(string pythonOutput, CancellationToken cancellationToken)
    {
        try
        {
            // Look for JSON report file generated by Python script
            var reportPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "python_modules",
                "mining_optimization_report.json"
            );

            if (!File.Exists(reportPath))
            {
                _logger.LogDebug("Kein Optimization Report gefunden - verwende Python Output");
                await _db.StringSetAsync("mining:optimization:last_run", pythonOutput, TimeSpan.FromHours(1));
                await _db.StringSetAsync("mining:optimization:timestamp", DateTime.UtcNow.ToString("o"), TimeSpan.FromHours(1));
                return;
            }

            var jsonContent = await File.ReadAllTextAsync(reportPath, cancellationToken);
            var report = JsonSerializer.Deserialize<JsonDocument>(jsonContent);

            if (report != null)
            {
                // Cache the complete report
                await _db.StringSetAsync("mining:optimization:report", jsonContent, TimeSpan.FromHours(1));
                await _db.StringSetAsync("mining:optimization:timestamp", DateTime.UtcNow.ToString("o"), TimeSpan.FromHours(1));

                // Extract and cache key metrics if available
                if (report.RootElement.TryGetProperty("total_profit", out var profit))
                {
                    await _db.StringSetAsync("mining:optimization:total_profit", profit.ToString(), TimeSpan.FromHours(1));
                }

                if (report.RootElement.TryGetProperty("best_algorithm", out var bestAlgo))
                {
                    await _db.StringSetAsync("mining:optimization:best_algorithm", bestAlgo.GetString() ?? "", TimeSpan.FromHours(1));
                }

                _logger.LogInformation("Optimization Report erfolgreich im Cache gespeichert");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Fehler beim Cachen der Optimization Results");
        }
    }
}
